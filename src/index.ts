import bind from "bind-decorator"
import { generateID, mountObserver, pickRan } from "./helpers"
import { LogSystem } from "./logSystem"
import { loadUI } from "./UI"
import { GameCanvas } from "./UI/gameCanvas"
import { InputSelect } from "./UI/inputSelect"
import { PhysicalSystem } from "./System/physical"
import { CollisionSystem } from "./System/collision"
import { InputSystem } from "./System/input"
import { AudioSystem } from "./System/audio"
import { PlayerComponent } from "./Component/player"
import { CapsuleComponent } from "./Component/capsule"
import { SequencerComponent } from "./Component/sequencer"

type UIComponent = InputSelect | GameCanvas

class Main
{
	public static run()
	{
		new Main()
	}

	private logSystem: LogSystem

	private components: UIComponent[]

	private physicalSystem: PhysicalSystem

	private collisionSystem: CollisionSystem

	private inputSystem: InputSystem

	private audioSystem: AudioSystem

	private player: [string, PlayerComponent][]

	private capsule: [string, CapsuleComponent][]

	private sequencer: [string, SequencerComponent][]

	private entities: Record<string, Component>

	constructor()
	{
		this.physicalSystem = new PhysicalSystem()

		this.collisionSystem = new CollisionSystem( this.physicalSystem )

		this.audioSystem = new AudioSystem()

		this.inputSystem = new InputSystem()

		/**
		 * The input system emits an input ID for each
		 * controller that is detected. This event triggers
		 * creating a player, and connects that player to
		 * the controller ID.
		 * 
		 * The input select UI displays the players that are
		 * connected.
		 */
		this.inputSystem.stringObservable.subscribe( {
			next: inputID =>
			{
				const playerCount = this.player.length + 1

				this.createPlayer( inputID, playerCount )

				for ( const component of this.components )
				{
					if ( component instanceof InputSelect )
					{
						component.setPlayer( playerCount )
					}
				}
			}
		} )

		/**
		 * The input select UI displays different content based
		 * on the state of the input system (e.g. selecting players,
		 * errors, etc). When the system is in a ready state, this
		 * means everything is ready to render, so more entities
		 * are generated.
		 */
		this.inputSystem.inputStateObservable.subscribe( {
			next: state =>
			{
				if ( state === `ready` ) this.generateEntities()

				for ( const component of this.components )
				{
					if ( component instanceof InputSelect )
					{
						component.next( state )
					}
				}
			}
		} )

		this.components = []

		this.player = []

		this.sequencer = []

		this.capsule = []

		this.entities = {}

		/**
		 * The mount system is used by the UI components to let
		 * out main class know when it has been registered into
		 * the web component registry. This makes it possible
		 * to observe these instances, and trigger various
		 * public methods.
		 */
		mountObserver.subscribe( { next: this.loadComponent } )

		this.logSystem = new LogSystem()

		// Build and mount the UI to the DOM
		loadUI()
	}

	@bind
	private loadComponent<T>( component: T )
	{
		this.logSystem.next( { level: `info`, message: `Got component: ${component}` } )

		if (
			component instanceof InputSelect
			|| component instanceof GameCanvas )
		{
			// store components for later use
			this.components.push( component )

			if ( component instanceof InputSelect )
			{
				/**
				 * Input selector emits the selected mode
				 * (controller or keyboard). This correlates
				 * with the first user input event, so anything
				 * that requires user interaction before loading
				 * can now be run. That includes the web audio api,
				 * and if controller is selected, web serial api.
				 * Also, canvas component's render loop is started.
				 */
				component.inputModeObservable.subscribe( {
					next: mode =>
					{
						this.audioSystem.init()

						this.inputSystem.init( mode )

						this.components.forEach( c =>
							c instanceof GameCanvas && c.init() )
					}
				} )
			}

			if ( component instanceof GameCanvas )
			{
				/**
				 * When there is access to the canvas, subscribe to the
				 * update loop event triggered by the animation loop, which
				 * gives access to the time delta for smooth animation calculations.
				 */
				component.updateLoopObservable.subscribe( {
					next: ( { ctx, delta } ) => this.update( delta, ctx )
				} )
			}
		}
	}

	/**
	 * Creates a new player entity
	 * @param inputID input ID generated by input system on input connection
	 * @param playerCount the number corresponding to the player
	 */
	private createPlayer( inputID: string, playerCount: number )
	{
		const id = generateID()

		const player = new PlayerComponent( inputID, playerCount )

		this.entities[ id ] = player

		this.emitEntity( id, player )

		this.player.push( [ id, player ] )
	}

	/**
	 * Capsules are used by players to "draw" sequencers
	 * This is why creating a capsule entity also generates a
	 * corresponding sequence entity.
	 */
	private createCapsule()
	{
		const capsuleID = generateID()

		const sequencerID = generateID()

		const capsule = new CapsuleComponent( sequencerID )

		this.entities[ capsuleID ] = capsule

		this.emitEntity( capsuleID, capsule )

		this.capsule.push( [ capsuleID, capsule ] )

		this.createSequencer( capsuleID, sequencerID )
	}

	/**
	 * Sequencer entity determine the sounds, timings, and rendering
	 * of the sequencer forms
	 * @param capsuleID Corresponding capsule that controls the sequence location
	 * @param sequencerID Id generated and used by the capsule
	 */
	private createSequencer( capsuleID: string, sequencerID: string )
	{
		const types: SoundType[] = [ `beat`, `synth` ]

		const sequencer = new SequencerComponent( capsuleID, pickRan( types ) )
		
		this.entities[ sequencerID ] = sequencer

		this.emitEntity( sequencerID, sequencer )

		this.sequencer.push( [ sequencerID, sequencer ] )
	}

	/**
	 * Gradually emit new capsules
	 */
	private generateEntities()
	{
		let count = 0

		setTimeout( () =>
		{
			this.createCapsule()

			count += 1
		}, 100 )

		const int = setInterval( () =>
		{
			this.createCapsule()

			count += 1

			if ( count === 7 ) clearInterval( int )
		}, 1000 )
	}

	/**
	 * Send the new entities to the various systems to be managed
	 * This could be more efficient, but it works nonetheless
	 * @param id entity id
	 * @param instance instance of the entity
	 */
	private emitEntity( id: string, instance: Component )
	{
		this.physicalSystem.next( { id, instance } )

		this.collisionSystem.next( { id, instance } )

		this.inputSystem.next( { id, instance } )

		this.audioSystem.next( { id, instance } )
	}

	/**
	 * The update loop triggers all state updates (audio
	 * manages its own state) for relevant systems, then
	 * draws all the entities.
	 * @param delta time delta created by animation loop
	 * @param ctx canvas rendering context for calculations
	 */
	private update( delta: number, ctx: CanvasRenderingContext2D )
	{
		this.inputSystem.update()

		this.physicalSystem.update( delta, ctx )

		this.collisionSystem.update( ctx )

		for( const sequencer of this.sequencer )
		{
			sequencer[ 1 ].draw( ctx )
		}

		for( const player of this.player )
		{
			player[ 1 ].draw( ctx, this.physicalSystem.pos( player[ 0 ] ) )
		}

		for( const capsule of this.capsule )
		{
			capsule[ 1 ].draw( ctx, this.physicalSystem.pos( capsule[ 0 ] ) )
		}
	}
}

Main.run()